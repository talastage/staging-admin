import{l as e}from"../_/nitro.mjs";import{aV as t,aA as o,aW as r,f as a,aS as s,aT as n,aU as c}from"./server.mjs";import{computed as i,toValue as u,reactive as l}from"vue";import{u as h}from"./asyncData-BkL_fZdA.mjs";function useFetch(e,t,o){const[r={},a]="string"==typeof t?[{},t]:[t,o],f=i((()=>u(e))),d=r.key||s([a,"string"==typeof f.value?f.value:"",...generateOptionSegments(r)]);if(!d||"string"!=typeof d)throw new TypeError("[nuxt] [useFetch] key must be a string: "+d);if(!e)throw new Error("[nuxt] [useFetch] request is missing.");const p=d===a?"$f"+d:d;if(!r.baseURL&&"string"==typeof f.value&&"/"===f.value[0]&&"/"===f.value[1])throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:m,lazy:v,default:y,transform:b,pick:g,watch:w,immediate:T,getCachedData:A,deep:E,dedupe:R,...C}=r,U=l({...n,...C,cache:"boolean"==typeof r.cache?void 0:r.cache}),k={server:m,lazy:v,default:y,transform:b,pick:g,immediate:T,getCachedData:A,deep:E,dedupe:R,watch:!1===w?[]:[U,f,...w||[]]};let q;return h(p,(()=>{var e;null==(e=null==q?void 0:q.abort)||e.call(q,new DOMException("Request aborted as another request to the same endpoint was initiated.","AbortError")),q="undefined"!=typeof AbortController?new AbortController:{};const t=u(r.timeout);let o;t&&(o=setTimeout((()=>q.abort(new DOMException("Request aborted due to timeout.","AbortError"))),t),q.signal.onabort=()=>clearTimeout(o));let a=r.$fetch||globalThis.$fetch;if(!r.$fetch){"string"==typeof f.value&&"/"===f.value[0]&&(!u(r.baseURL)||"/"===u(r.baseURL)[0])&&(a=c())}return a(f.value,{signal:q.signal,...U}).finally((()=>{clearTimeout(o)}))}),k)}function generateOptionSegments(e){var t;const o=[(null==(t=u(e.method))?void 0:t.toUpperCase())||"GET",u(e.baseURL)];for(const t of[e.params||e.query]){const e=u(t);if(!e)continue;const r={};for(const[t,o]of Object.entries(e))r[u(t)]=u(o);o.push(r)}return o}function useApi(){const s=a(),n=t("auth_token"),c=t("XSRF-TOKEN"),i={baseURL:s.public.backendUrl,credentials:"include",headers:{Accept:"application/json","Content-Type":"application/json"},onRequest({options:e}){n.value&&(e.headers={...e.headers,Authorization:`Bearer ${n.value}`}),c.value&&(e.headers={...e.headers,"X-XSRF-TOKEN":decodeURIComponent(c.value)})},onRequestError({error:e}){console.error("Request error:",e)},onResponse({response:e}){401===e.status&&o("/login")},onResponseError({error:e}){console.error("Response error:",e),404===e.statusCode?r({statusCode:404,message:"Resource not found"}):e.statusCode>=500&&r({statusCode:500,message:"Server error"})}};async function fetchCsrfToken(){await useFetch("/sanctum/csrf-cookie",{baseURL:s.public.backendUrl,credentials:"include"},"$UqgiltlUfE")}async function fetchApi(t,o={}){try{console.log(`Fetching URL: ${t} with options:`,o);const r=e(o,i);"GET"===r.method&&(r.cache=r.cache||"no-cache");const{data:a,error:s}=await useFetch(t,r,"$HgqqyPIEgZ");if(s.value)throw console.error("Fetch error:",s.value),s.value;if(!a.value)throw console.error("No data received from the API"),new Error("No data received from the API");return a.value}catch(e){throw console.error("API call error:",e),e}}return{get:(e,t)=>fetchApi(e,{...t,method:"GET"}),post:async(e,t,o)=>(await fetchCsrfToken(),fetchApi(e,{...o,method:"POST",body:t})),put:async(e,t,o)=>(await fetchCsrfToken(),fetchApi(e,{...o,method:"PUT",body:t})),patch:async(e,t,o)=>(await fetchCsrfToken(),fetchApi(e,{...o,method:"PATCH",body:t})),delete:async(e,t)=>(await fetchCsrfToken(),fetchApi(e,{...t,method:"DELETE"}))}}export{useApi as u};
