import{ref as a,shallowRef as e,toRef as t,getCurrentInstance as r,onServerPrefetch as s,unref as n}from"vue";import{u as l,aX as i,aY as o}from"./server.mjs";function useAsyncData(...c){var d,u,y,f,p,m,_,D;const v="string"==typeof c[c.length-1]?c.pop():void 0;"string"!=typeof c[0]&&c.unshift(v);let[g,h,P={}]=c;if("string"!=typeof g)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof h)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const w=l(),k=h;P.server=null==(d=P.server)||d,P.default=null!=(u=P.default)?u:()=>i.value,P.getCachedData=null!=(y=P.getCachedData)?y:()=>w.isHydrating?w.payload.data[g]:w.static.data[g],P.lazy=null!=(f=P.lazy)&&f,P.immediate=null==(p=P.immediate)||p,P.deep=null!=(m=P.deep)?m:i.deep,P.dedupe=null!=(_=P.dedupe)?_:"cancel";const x=P.getCachedData(g,w),C=null!=x;if(!w._asyncData[g]||!P.immediate){null!=(D=w.payload._errors)[g]||(D[g]=i.errorValue);const r=P.deep?a:e;w._asyncData[g]={data:r(C?x:P.default()),pending:a(!C),error:t(w.payload._errors,g),status:a("idle"),_default:P.default}}const V={...w._asyncData[g]};delete V._default,V.refresh=V.execute=(a={})=>{var e,t;if(w._asyncDataPromises[g]){if("defer"===(t=null!=(e=a.dedupe)?e:P.dedupe)||!1===t)return w._asyncDataPromises[g];w._asyncDataPromises[g].cancelled=!0}if(a._initial||w.isHydrating&&!1!==a._initial){const e=a._initial?x:P.getCachedData(g,w);if(null!=e)return Promise.resolve(e)}V.pending.value=!0,V.status.value="pending";const r=new Promise(((a,e)=>{try{a(k(w))}catch(a){e(a)}})).then((async a=>{if(r.cancelled)return w._asyncDataPromises[g];let e=a;P.transform&&(e=await P.transform(a)),P.pick&&(e=function(a,e){const t={};for(const r of e)t[r]=a[r];return t}(e,P.pick)),w.payload.data[g]=e,V.data.value=e,V.error.value=i.errorValue,V.status.value="success"})).catch((a=>{if(r.cancelled)return w._asyncDataPromises[g];V.error.value=o(a),V.data.value=n(P.default()),V.status.value="error"})).finally((()=>{r.cancelled||(V.pending.value=!1,delete w._asyncDataPromises[g])}));return w._asyncDataPromises[g]=r,w._asyncDataPromises[g]},V.clear=()=>function(a,e){e in a.payload.data&&(a.payload.data[e]=void 0);e in a.payload._errors&&(a.payload._errors[e]=i.errorValue);a._asyncData[e]&&(a._asyncData[e].data.value=void 0,a._asyncData[e].error.value=i.errorValue,a._asyncData[e].pending.value=!1,a._asyncData[e].status.value="idle");e in a._asyncDataPromises&&(a._asyncDataPromises[e]&&(a._asyncDataPromises[e].cancelled=!0),a._asyncDataPromises[e]=void 0)}(w,g);if(!1!==P.server&&w.payload.serverRendered&&P.immediate){const a=V.refresh({_initial:!0});r()?s((()=>a)):w.hook("app:created",(async()=>{await a}))}const b=Promise.resolve(w._asyncDataPromises[g]).then((()=>V));return Object.assign(b,V),b}export{useAsyncData as u};
